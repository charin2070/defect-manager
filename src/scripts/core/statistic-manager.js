class StatisticManager extends Reactive {
    constructor(issues) {
        super(document.body);
        this.issues = issues;     
            
        if (this.issues) {
            this.updateStatistics(this.issues);
        }

        this.setupSubscriptions();

    }

    updateStatistics(issues) {
        if (!issues || !Array.isArray(issues)) {
            console.warn('[StatisticManager] updateStatistics requires a defined array of issues');
            return;
        }

        const issueStatistics = StatisticManager.getStructuredStatistics(issues);
        log(issueStatistics, 'üìä [StatisticManager] Issue statistics');
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
        const formattedStatistics = {
            defects: {
                total: {
                    unresolved: issueStatistics.statisticsTotal.unresolved || [],
                },
                currentMonth: {
                    created: issueStatistics.currentMonthStatistics.created || [],
                }
            },
            requests: {
                total: {
                    unresolved: issueStatistics.statisticsTotal.unresolved || [],
                },
                currentMonth: {
                    created: issueStatistics.currentMonthStatistics.created || [],
                }
            }
        };

        this.setState({ statistics: formattedStatistics }, '[StatisticManager] updateStatistics');
        log(formattedStatistics, 'üìä [StatisticManager] Statistics updated');
    }

    setupSubscriptions() {
    }

    // Example of Issue object
    exampleIssue = {
        "taskId": "ADIRINC-1203",
        "created": "2023-08-10T10:17:00.000Z",
        "resolved": "2024-02-07T08:49:00.000Z",
        "reports": 67,
        "slaDate": "2023-11-01T21:00:00.000Z",
        "status": "–ó–∞–∫—Ä—ã—Ç",
        "state": null,
        "description": "10.08 –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º –ø—Ä–æ—Å—Ç–∞–≤–∏–ª—Å—è –∑–∞–ø—Ä–µ—Ç –Ω–∞ —Ç–æ—Ä–≥–æ–≤–ª—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º,¬†\r  –ø–æ–¥—Ä–æ–±–Ω–µ–µ –≤¬†[https://rc.alfa-bank.net/channel/adir-avarii?msg=AvtnNSMQZRMhGMtdX]",
        "summary": "–ò–∑–º–µ–Ω–µ–Ω–∏–µ IdTradePeriodStatus –≤ [AdFront].[fi].[FinInfoExt] –∏ [AdFront].[ts].[FinInfoExt]",
        "type": "–î–µ—Ñ–µ–∫—Ç –ø—Ä–æ–º—Å—Ä–µ–¥—ã",
        "priority": null,
        "assignee": "U_M00ZM",
        "reporter": null,
        "team": "Core",
        "isOverdue": null,
        "source": "ADIRINC-1203,3529833,U_M00ZM,–ó–∞–∫—Ä—ã—Ç,10.08.2023 13:17,,,,,–î–µ—Ñ–µ–∫—Ç –ø—Ä–æ–º—Å—Ä–µ–¥—ã,07.02.2024 11:49,2023-11-02 00:00:00.0,\"10.08 –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º –ø—Ä–æ—Å—Ç–∞–≤–∏–ª—Å—è –∑–∞–ø—Ä–µ—Ç –Ω–∞ —Ç–æ—Ä–≥–æ–≤–ª—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º,¬†\r  –ø–æ–¥—Ä–æ–±–Ω–µ–µ –≤¬†[https://rc.alfa-bank.net/channel/adir-avarii?msg=AvtnNSMQZRMhGMtdX]\",,67.0,Core,,–ò–∑–º–µ–Ω–µ–Ω–∏–µ IdTradePeriodStatus –≤ [AdFront].[fi].[FinInfoExt] –∏ [AdFront].[ts].[FinInfoExt],–ü–æ—Ä—Ç—Ñ–µ–ª—å - –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–æ—Å—Ç–∞–≤ –ø–æ—Ä—Ç—Ñ–µ–ª—è (–≤–∫–ª. –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –º–∏–Ω—É—Å –ø–æ —Å—á–µ—Ç—É) (1) - critical,,,08.08.2024 23:49",
        "notes": null,
        "alarms": null,
        "component": "",
        "updated": "2024-08-08T20:49:00.000Z",
        "Issue id": "3529833",
        "labels": "",
        "Custom field (description )": "",
        "Custom field (Business Summary)": "",
        "Custom field (Mobile application component)": ""
    }

    // Statiistics structure
    issueStatistics = {
            unresolved: [], // –ù–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ
            resolved: [], // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ
            rejected: [], // –û—Ç–∫–ª–æ–Ω–µ–Ω–Ω—ã–µ
            rejectedByTeam: [], // –û—Ç–∫–ª–æ–Ω–µ–Ω—ã –∫–æ–º–∞–Ω–¥–æ–π —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏
            created: [],  // –°–æ–∑–¥–∞–Ω–Ω—ã–µ
            verified: [], // –ü—Ä–∏–Ω—è—Ç—ã –∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—é
            overdue: [], // –ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ
            averageResolutionTime: 0, // –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            reports: 0 // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞—â–µ–Ω–∏–π –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–∞ –Ω–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö
    }

    static getStructuredStatistics(issues) {
        const statisticsStructure = {
            defects: {
                resolved: {
                    count: 0,
                    resolutionDates: {},
                    slaDates: {}
                },
                unresolved: {
                    count: 0,
                    creationDates: {}
                },
                rejected: {
                    count: 0,
                    rejectionDates: {}
                }
            },
            requests: {
                resolved: {
                    count: 0
                },
                unresolved: {
                    count: 0
                },
                rejected: {
                    count: 0
                }
            }
        };
    
        if (!issues || !Array.isArray(issues)) {
            console.warn("[IndexManager] getStructuredStatistics requires an array of issues.");
            return statisticsStructure;
        }
    
        issues.forEach(issue => {
            const type = issue.type;
            const state = issue.state;
            const taskId = issue.taskId;
            const creationDate = issue.created ? new Date(issue.created).toISOString().split('T')[0] : null;
            const resolvedDate = issue.resolved ? new Date(issue.resolved).toISOString().split('T')[0] : null;
            const slaDate = issue.sla ? new Date(issue.sla).toISOString().split('T')[0] : null;
    
            if (type === 'defect') {
                if (state === 'resolved') {
                    statisticsStructure.defects.resolved.count++;
                    if (resolvedDate) {
                        statisticsStructure.defects.resolved.resolutionDates[resolvedDate] =
                            statisticsStructure.defects.resolved.resolutionDates[resolvedDate] || [];
                        statisticsStructure.defects.resolved.resolutionDates[resolvedDate].push(taskId);
                    }
                    if (slaDate) {
                        statisticsStructure.defects.resolved.slaDates[slaDate] =
                            statisticsStructure.defects.resolved.slaDates[slaDate] || [];
                        statisticsStructure.defects.resolved.slaDates[slaDate].push(taskId);
                    }
                } else if (state === 'unresolved') {
                    statisticsStructure.defects.unresolved.count++;
                    if (creationDate) {
                        statisticsStructure.defects.unresolved.creationDates[creationDate] =
                            statisticsStructure.defects.unresolved.creationDates[creationDate] || [];
                        statisticsStructure.defects.unresolved.creationDates[creationDate].push(taskId);
                    }
                } else if (state === 'rejected') {
                    statisticsStructure.defects.rejected.count++;
                    if (resolvedDate) {
                        statisticsStructure.defects.rejected.rejectionDates[resolvedDate] =
                            statisticsStructure.defects.rejected.rejectionDates[resolvedDate] || [];
                        statisticsStructure.defects.rejected.rejectionDates[resolvedDate].push(taskId);
                    }
                }
            } else if (type === 'request') {
                const category = statisticsStructure.requests[state];
                if (category) {
                    category.count++;
                    category[creationDate] = category[creationDate] || [];
                    category[creationDate].push(taskId);
                }
            }
        });
    
        return statisticsStructure;
    }

    static getIssueStatistics(issues) {
        const now = new Date();
        const startOfCurrentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        const last30Days = new Date(now);
        last30Days.setDate(now.getDate() - 30);
        const last90Days = new Date(now);
        last90Days.setDate(now.getDate() - 90);
    
        const statisticsTotal = {
            unresolved: [],
            resolved: [],
            rejected: [],
            rejectedByTeam: [],
            created: [],
            verified: [],
            averageResolutionTime: 0,
            reports: 0
        };
    
        const currentMonthStatistics = JSON.parse(JSON.stringify(statisticsTotal));
        const last30daysStatistics = JSON.parse(JSON.stringify(statisticsTotal));
        const last90daysStatistics = JSON.parse(JSON.stringify(statisticsTotal));
    
        if (!issues || !Array.isArray(issues)) {
            console.error("[StatisticManager] getIssueStatistics requires an array of issues.");
            return { statisticsTotal, currentMonthStatistics, last30daysStatistics, last90daysStatistics };
        }
    
        let totalResolutionTime = 0;
        let resolvedCount = 0;
    
        const updateStatistics = (statistics, issue, createdDate, resolvedDate) => {
            if (issue.state === 'unresolved') {
                statistics.unresolved.push(issue);
                statistics.reports += issue.reports || 0;
            }
    
            if (issue.state === 'resolved') {
                statistics.resolved.push(issue);
                if (resolvedDate) {
                    statistics.totalResolutionTime = (statistics.totalResolutionTime || 0) + (resolvedDate - createdDate);
                    statistics.resolvedCount = (statistics.resolvedCount || 0) + 1;
                }
            }
    
            if (issue.state === 'rejected') {
                statistics.rejected.push(issue);
            }
    
            if (issue.status === '–û—Ç–∫–ª–æ–Ω–µ–Ω –∫–æ–º–∞–Ω–¥–æ–π') {
                statistics.rejectedByTeam.push(issue);
            }
    
            if (issue.status !== '–ù–æ–≤—ã–π' && issue.state !== 'unresolved') {
                statistics.verified.push(issue);
            }
        };
    
        issues.forEach(issue => {
            const createdDate = new Date(issue.created);
            const resolvedDate = issue.resolved ? new Date(issue.resolved) : null;
    
            // Update Total Statistics
            updateStatistics(statisticsTotal, issue, createdDate, resolvedDate);
    
            // Update Current Month Statistics
            if (createdDate >= startOfCurrentMonth || (resolvedDate && resolvedDate >= startOfCurrentMonth)) {
                updateStatistics(currentMonthStatistics, issue, createdDate, resolvedDate);
            }
    
            // Update Last 30 Days Statistics
            if (createdDate >= last30Days || (resolvedDate && resolvedDate >= last30Days)) {
                updateStatistics(last30daysStatistics, issue, createdDate, resolvedDate);
            }
    
            // Update Last 90 Days Statistics
            if (createdDate >= last90Days || (resolvedDate && resolvedDate >= last90Days)) {
                updateStatistics(last90daysStatistics, issue, createdDate, resolvedDate);
            }
        });
    
        // Finalize Average Resolution Time Calculation
        const finalizeAverageResolutionTime = (statistics) => {
            if (statistics.resolvedCount > 0) {
                statistics.averageResolutionTime = 
                    (statistics.totalResolutionTime / statistics.resolvedCount) / (1000 * 60 * 60 * 24);
            }
            delete statistics.totalResolutionTime;
            delete statistics.resolvedCount;
        };
    
        finalizeAverageResolutionTime(statisticsTotal);
        finalizeAverageResolutionTime(currentMonthStatistics);
        finalizeAverageResolutionTime(last30daysStatistics);
        finalizeAverageResolutionTime(last90daysStatistics);
    
        return { statisticsTotal, currentMonthStatistics, last30daysStatistics, last90daysStatistics };
    }
    

    static getStatisticsFromIndex(index, issues, dateRange) {
        const { dateStart: startDate, dateEnd: endDate } = dateRange;
        const statistics = {
            unresolved: [],
            resolved: [],
            rejected: [],
            rejectedByTeam: [],
            created: [],
            verified: [],
            overdue: [],
            averageResolutionTime: 0,
            reports: 0
        };

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º Set –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ –∏ –∏—Å–∫–ª—é—á–µ–Ω–∏—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
        const processedTasks = new Set();
        let totalResolutionTime = 0;
        let resolvedCount = 0;

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –∑–∞–¥–∞—á
        if (index.created) {
            Object.entries(index.created).forEach(([dateStr, taskIds]) => {
                const date = new Date(dateStr);
                if (date >= startDate && date <= endDate) {
                    taskIds.forEach(taskId => {
                        if (!processedTasks.has(taskId)) {
                            const issue = issues[taskId];
                            if (issue) {
                                statistics.created.push(issue);
                                processedTasks.add(taskId);
                            }
                        }
                    });
                }
            });
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á –∏ –ø–æ–¥—Å—á–µ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
        if (index.resolved) {
            Object.entries(index.resolved).forEach(([dateStr, taskIds]) => {
                const date = new Date(dateStr);
                if (date >= startDate && date <= endDate) {
                    taskIds.forEach(taskId => {
                        if (!processedTasks.has(taskId)) {
                            const issue = issues[taskId];
                            if (issue) {
                                statistics.resolved.push(issue);
                                processedTasks.add(taskId);

                                // –ü–æ–¥—Å—á–µ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ —Ä–µ—à–µ–Ω–∏—è
                                if (issue.created && issue.resolved) {
                                    const createdDate = new Date(issue.created);
                                    const resolvedDate = new Date(issue.resolved);
                                    totalResolutionTime += resolvedDate - createdDate;
                                    resolvedCount++;
                                }
                            }
                        }
                    });
                }
            });
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á
        if (index.rejected) {
            Object.entries(index.rejected).forEach(([dateStr, taskIds]) => {
                const date = new Date(dateStr);
                if (date >= startDate && date <= endDate) {
                    taskIds.forEach(taskId => {
                        if (!processedTasks.has(taskId)) {
                            const issue = issues[taskId];
                            if (issue) {
                                if (issue.team) {
                                    statistics.rejectedByTeam.push(issue);
                                } else {
                                    statistics.rejected.push(issue);
                                }
                                processedTasks.add(taskId);
                            }
                        }
                    });
                }
            });
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π (verified, unresolved, overdue)
        if (index.state) {
            Object.entries(index.state).forEach(([state, taskIds]) => {
                taskIds.forEach(taskId => {
                    if (!processedTasks.has(taskId)) {
                        const issue = issues[taskId];
                        if (issue) {
                            const createdDate = new Date(issue.created);
                            if (createdDate >= startDate && createdDate <= endDate) {
                                switch (state) {
                                    case 'verified':
                                        statistics.verified.push(issue);
                                        break;
                                    case 'unresolved':
                                        statistics.unresolved.push(issue);
                                        statistics.reports += issue.reports || 0;
                                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ
                                        if (issue.slaDate && new Date(issue.slaDate) < new Date()) {
                                            statistics.overdue.push(issue);
                                        }
                                        break;
                                }
                                processedTasks.add(taskId);
                            }
                        }
                    }
                });
            });
        }

        // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ —Ä–µ—à–µ–Ω–∏—è
        statistics.averageResolutionTime = resolvedCount > 0 
            ? totalResolutionTime / resolvedCount 
            : 0;

        console.log('Processing statistics for range:', { startDate, endDate });
        console.log('Index structure:', Object.keys(index));
        console.log('Number of issues:', Object.keys(issues).length);
        console.log('Processed tasks:', processedTasks.size);

        return statistics;
    }

    
}